// cmd/gen-events/main.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

func main() {
	var (
		dir         = flag.String("dir", ".", "directory to scan for Go files")
		out         = flag.String("out", "events_names_gen.go", "output file path")
		pkg         = flag.String("pkg", "", "package name for generated file (required)")
		tag         = flag.String("tag", "@event", "doc tag that marks a struct as an event")
		emitMethods = flag.Bool("emit-methods", false, "also emit EventName() methods for each event type")
	)
	flag.Parse()

	if *pkg == "" {
		fail("missing required -pkg flag")
	}

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, *dir, func(fi os.FileInfo) bool {
		// ignore tests and already-generated files
		name := fi.Name()
		if strings.HasSuffix(name, "_test.go") {
			return false
		}
		if strings.HasSuffix(name, "_gen.go") || strings.HasSuffix(name, ".pb.go") {
			return false
		}
		return strings.HasSuffix(name, ".go")
	}, parser.ParseComments)
	if err != nil {
		fail("parse dir: %v", err)
	}

	// If there are multiple packages in dir, prefer the one matching -pkg.
	var pkgAst *ast.Package
	if p, ok := pkgs[*pkg]; ok {
		pkgAst = p
	} else if len(pkgs) == 1 {
		for _, p := range pkgs {
			pkgAst = p
		}
	} else {
		fail("could not find package %q in %s", *pkg, *dir)
	}

	events := make([]string, 0, 16)

	for _, f := range pkgAst.Files {
		ast.Inspect(f, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			if !ok || decl.Tok != token.TYPE {
				return true
			}
			for _, spec := range decl.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				st, ok := ts.Type.(*ast.StructType)
				if !ok || st == nil {
					continue
				}
				// Check doc comments on the type and on the GenDecl.
				if hasTag(decl.Doc, *tag) || hasTag(ts.Doc, *tag) {
					events = append(events, ts.Name.Name)
				}
			}
			return true
		})
	}

	// De-dup + sort for stable output
	events = uniqueSorted(events)

	if len(events) == 0 {
		// Still emit a small file so go:generate doesnâ€™t fail the build.
		if err := os.WriteFile(*out, minimal(*pkg), 0644); err != nil {
			fail("write minimal: %v", err)
		}
		return
	}

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by gen-events; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Generated at %s\n\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(&buf, "package %s\n\n", *pkg)

	// Emit const block
	fmt.Fprintf(&buf, "const (\n")
	for _, name := range events {
		fmt.Fprintf(&buf, "\tEvent%s = %q\n", name, name)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Optional: emit a set/map of names
	fmt.Fprintf(&buf, "var AllEventNames = []string{\n")
	for _, name := range events {
		fmt.Fprintf(&buf, "\t%q,\n", name)
	}
	fmt.Fprintf(&buf, "}\n\n")

	fmt.Fprintf(&buf, "var EventNameSet = map[string]struct{}{\n")
	for _, name := range events {
		fmt.Fprintf(&buf, "\t%q: {},\n", name)
	}
	fmt.Fprintf(&buf, "}\n\n")

	// Optional: emit methods
	if *emitMethods {
		// Emit a tiny interface (safe to re-declare here in the same package, or you can define it in your hand-written code).
		fmt.Fprintf(&buf, "type NamedEvent interface{ EventName() string }\n\n")
		for _, name := range events {
			fmt.Fprintf(&buf, "func (%s) EventName() string { return %q }\n", name, name)
		}
		fmt.Fprintf(&buf, "\n")
	}

	// Format
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write raw to help troubleshoot.
		_ = os.WriteFile(*out, buf.Bytes(), 0644)
		fail("format output: %v (wrote unformatted output to %s)", err, *out)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(*out), 0755); err != nil {
		fail("mkdir: %v", err)
	}
	if err := os.WriteFile(*out, formatted, 0644); err != nil {
		fail("write output: %v", err)
	}
}

func hasTag(cg *ast.CommentGroup, tag string) bool {
	if cg == nil {
		return false
	}
	for _, c := range cg.List {
		if strings.Contains(c.Text, tag) {
			return true
		}
	}
	return false
}

func uniqueSorted(in []string) []string {
	seen := make(map[string]struct{}, len(in))
	var out []string
	for _, s := range in {
		if _, ok := seen[s]; ok {
			continue
		}
		seen[s] = struct{}{}
		out = append(out, s)
	}
	sort.Strings(out)
	return out
}

func minimal(pkg string) []byte {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by gen-events; DO NOT EDIT.\n\npackage %s\n\n", pkg)
	fmt.Fprintf(&buf, "var AllEventNames = []string{}\nvar EventNameSet = map[string]struct{}{}\n")
	return buf.Bytes()
}

func fail(formatStr string, args ...any) {
	fmt.Fprintf(os.Stderr, "gen-events: "+formatStr+"\n", args...)
	os.Exit(1)
}